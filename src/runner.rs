use thiserror::Error;

use crate::function::{CallContext, CallError, Library};
use crate::model::{Node, NodeError, OpCode, Operands, Value, ValueError};
use crate::story::Story;
use crate::variables::VariableStore;

/// An event generated by stepping through multiple [Story] instructions that can
/// inform the user on how the narrative is unfolding.
#[derive(Debug)]
pub enum StoryEvent {
    Started,
    AddOption {
        enabled: bool,
        key: String,
        substitutions: Vec<String>,
        target: String,
    },
    ShowOptions,
    ShowLine {
        key: String,
        substitutions: Vec<String>,
    },
    Command(String),
    Complete,
}

/// A [`StoryCheckpoint`] represents an addressable point in the [Story]. It can be saved
/// and later resumed to reload
#[derive(Clone)]
pub struct StoryCheckpoint<'r> {
    /// The node the story checkpoint was created at, if any. If none, the [StoryRunner] will
    /// follow the starting node.
    node: &'r Node,

    /// Offset of the next instruction to execute within the node.
    node_instruction_offset: usize,

    /// The evaluation stack at the time of this checkpoint.
    stack: EvaluationStack,
}

impl<'r> StoryCheckpoint<'r> {
    const fn at(node: &'r Node, pc: usize, stack: EvaluationStack) -> Self {
        Self {
            node,
            node_instruction_offset: pc,
            stack,
        }
    }

    #[must_use]
    pub const fn new(node: &'r Node) -> StoryCheckpoint {
        Self {
            node,
            node_instruction_offset: 0,
            stack: EvaluationStack(vec![]),
        }
    }
}

/// The value stack.
#[derive(Clone)]
pub struct EvaluationStack(Vec<Value>);

impl EvaluationStack {
    pub fn pop_any(&mut self) -> Result<Value, ValueError> {
        self.0.pop().ok_or(ValueError::Missing)
    }

    pub fn peek_any(&mut self) -> Result<Value, ValueError> {
        self.0.get(0).cloned().ok_or(ValueError::Missing)
    }

    pub fn peek<T>(&mut self) -> Result<T, ValueError>
    where
        T: TryFrom<Value, Error = ValueError>,
    {
        self.0
            .get(0)
            .ok_or(ValueError::Missing)
            .and_then(|v| T::try_from(v.clone()))
    }

    pub fn pop<T>(&mut self) -> Result<T, ValueError>
    where
        T: TryFrom<Value, Error = ValueError>,
    {
        self.0
            .pop()
            .ok_or(ValueError::Missing)
            .and_then(|v| T::try_from(v))
    }

    pub fn push<T>(&mut self, value: T)
    where
        T: Into<Value>,
    {
        let v = value.into();
        self.0.push(v);
    }
}

/// An error that occurred during evaluation of a [Story].
#[derive(Error, Debug)]
pub enum StoryRunnerError {
    #[error("invalid program node model")]
    BadNode(#[from] NodeError),

    /// An error has occurred while interpreting or decoding an instruction.
    #[error("error while decoding instructions, illegal opcode: {0}")]
    InvalidInstruction(i32),

    #[error("error while calling function")]
    FunctionCall(#[from] CallError),

    #[error("error occurred evaluating value")]
    Evaluation(#[from] ValueError),
}

/// Driver for running and evaluating a [Story].
#[derive(Default)]
pub struct StoryRunner {
    library: Library,
}

impl StoryRunner {
    #[must_use]
    pub const fn new(library: Library) -> Self {
        Self { library }
    }

    /// Advance the story forward from the given [checkpoint].
    pub fn step<'a, V: VariableStore>(
        &'a self,
        story: &'a Story,
        checkpoint: StoryCheckpoint<'a>,
        variables: &mut V,
    ) -> Result<(StoryCheckpoint, StoryEvent), StoryRunnerError> {
        let StoryCheckpoint {
            mut node,
            node_instruction_offset: mut pc,
            mut stack,
        } = checkpoint;

        loop {
            let prev_pc = pc;
            let instruction = &node.instructions[pc];
            let operands = &instruction.operands;

            let opcode = OpCode::from_i32(instruction.opcode)
                .ok_or(StoryRunnerError::InvalidInstruction(instruction.opcode))?;

            eprintln!(
                "{}: {:?} ops={:?} stack={:?}",
                pc, opcode, operands, stack.0
            );

            match opcode {
                OpCode::JumpTo => {
                    let label_name = operands.at::<String>(0)?;
                    let label_offset = node.resolve_label(&label_name)?;

                    pc = label_offset;
                }
                OpCode::Jump => {
                    let label_name = stack.pop::<String>()?;
                    let label_offset = node.resolve_label(&label_name)?;

                    pc = label_offset;
                }
                OpCode::RunLine => {
                    let key = operands.at::<String>(0)?;

                    let substitutions = if operands.len() > 1 {
                        let expression_count = operands.at::<f32>(1)? as usize;
                        let mut substitutions = Vec::with_capacity(expression_count);

                        for index in (0..expression_count).rev() {
                            substitutions[index] = stack.pop::<String>()?;
                        }

                        substitutions
                    } else {
                        vec![]
                    };

                    pc += 1;

                    return Ok((
                        StoryCheckpoint::at(node, pc, stack),
                        StoryEvent::ShowLine { key, substitutions },
                    ));
                }
                OpCode::RunCommand => {
                    todo!()
                }
                OpCode::AddOption => {
                    let key = operands.at::<String>(0)?;
                    let target = operands.at::<String>(1)?;

                    let substitutions = if operands.len() > 2 {
                        let expression_count = operands.at::<f32>(2)? as usize;
                        let mut substitutions = Vec::with_capacity(expression_count);

                        for index in (0..expression_count).rev() {
                            substitutions[index] = stack.pop::<String>()?;
                        }

                        substitutions
                    } else {
                        vec![]
                    };

                    let enabled = if operands.len() > 3 && operands.at::<bool>(3)? {
                        stack.pop()?
                    } else {
                        true
                    };

                    pc += 1;

                    return Ok((
                        StoryCheckpoint::at(node, pc, stack),
                        StoryEvent::AddOption {
                            enabled,
                            key,
                            substitutions,
                            target,
                        },
                    ));
                }
                OpCode::ShowOptions => {
                    pc += 1;

                    return Ok((
                        StoryCheckpoint::at(node, pc, stack),
                        StoryEvent::ShowOptions,
                    ));
                }
                OpCode::PushString => stack.push(operands.at::<String>(0)?),
                OpCode::PushFloat => stack.push(operands.at::<f32>(0)?),
                OpCode::PushBool => stack.push(operands.at::<bool>(0)?),
                OpCode::PushNull => {
                    todo!()
                }
                OpCode::JumpIfFalse => {
                    let condition = stack.peek::<bool>()?;
                    if !condition {
                        let target_name = operands.at::<String>(0)?;
                        let target = node.resolve_label(&target_name)?;

                        pc = target;
                    }
                }
                OpCode::Pop => {
                    let _ = stack.pop_any()?;
                }
                OpCode::CallFunc => {
                    let name = operands.at::<String>(0)?;
                    let parameter_count = stack.pop::<f32>()? as usize;
                    let mut parameters = Vec::with_capacity(parameter_count);

                    for _ in 0..parameter_count {
                        parameters.push(stack.pop_any()?);
                    }

                    parameters.reverse();

                    let cx = CallContext {
                        node,
                        story,
                        variables,
                    };

                    if let Some(return_value) = self.library.call(name, cx, parameters)? {
                        stack.push(return_value);
                    }
                }
                OpCode::PushVariable => {
                    let var_name = operands.at::<String>(0)?;
                    let var_value = variables
                        .get(&var_name)
                        .or_else(|| story.initial_value(&var_name));

                    if let Some(value) = var_value {
                        stack.push(value.clone());
                    } else {
                        panic!("TODO: raise StoryRunnerError for missing default value")
                    }
                }
                OpCode::StoreVariable => {
                    let value = stack.peek_any()?;
                    let var_name = operands.at::<String>(0)?;

                    variables.set(&var_name, value);
                }
                OpCode::Stop => {
                    return Ok((StoryCheckpoint::at(node, pc, stack), StoryEvent::Complete))
                }
                OpCode::RunNode => {
                    let node_name = stack.pop::<String>()?;
                    let new_node = story.node(node_name).unwrap();

                    node = new_node;
                    pc = 0;
                }
            }

            if prev_pc == pc {
                pc += 1;
            }
        }
    }
}
